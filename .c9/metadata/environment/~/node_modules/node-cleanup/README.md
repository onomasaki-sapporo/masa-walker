{"changed":true,"filter":false,"title":"README.md","tooltip":"~/node_modules/node-cleanup/README.md","value":"history# node-cleanup\n\ninstalls custom cleanup handlers that run on exiting node\n\n## Installation\n\n```\nnpm install node-cleanup --save\n```\n\n## Overview\n\n`nodeCleanup()` installs functions that perform cleanup activities just before the node process exits. Let's call these functions \"cleanup handlers.\" The cleanup handlers run under the following conditions:\n\n- When the process exits normally (exit code 0).\n- When the process exits due to an error, such as an uncaught exception (exit code 1).\n- When the process receives one of the following POSIX signals: SIGINT (e.g. *Ctrl-C*), SIGHUP, SIGQUIT, or SIGTERM.\n\nThis solution has the following features:\n\n- Allows cleanup handlers to behave as a function of exit code and signal.\n- Allows multiple independent subsystems to install cleanup handlers.\n- Allows for asynchronous cleanup on receiving a signal by postponing process termination.\n- Allows for deferring to child processes the decision about whether a signal terminates the present process. For example, Emacs intercepts *Ctrl-C*, which should prevent its parent process from terminating.\n- Allows for writing custom messages to `stderr` on SIGINT (e.g. *Ctrl-C*) and uncaught exceptions, regardless of the number of cleanup handlers installed.\n- Allows for uninstalling all cleanup handlers, such as to change termination behavior after having intercepted and cleaned up for a signal.\n\nThe module also has an extensive test suite to help ensure reliability.\n\n## Usage\n\nHere is the typical way to use `nodeCleanup()`:\n\n```js\nvar nodeCleanup = require('node-cleanup');\n\nnodeCleanup(function (exitCode, signal) {\n    // release resources here before node exits\n});\n```\n\nIf you only want to install your own messages for *Ctrl-C* and uncaught exception (either or both), you can do this:\n\n```js\nnodeCleanup({\n    ctrl_C: \"{^C}\",\n    uncaughtException: \"Uh oh. Look what happened:\"\n});\n```\n\nTo get the default `stderr` messages, without installing a cleanup handler:\n\n```js\nnodeCleanup();\n```\n\nYou may also combine these to install a cleanup handler and `stderr` messages:\n\n```js\nnodeCleanup(function (exitCode, signal) {\n    // release resources here before node exits\n}, {\n    ctrl_C: \"{^C}\",\n    uncaughtException: \"Uh oh. Look what happened:\"\n});\n```\n\nYou may perform asynchronous cleanup upon receiving a signal, as follows:\n\n```js\nnodeCleanup(function (exitCode, signal) {\n    if (signal) {\n        unsavedData.save(function done() {\n            // calling process.exit() won't inform parent process of signal\n            process.kill(process.pid, signal);\n        });\n        nodeCleanup.uninstall(); // don't call cleanup handler again\n        return false;\n    }\n});\n```\n\nWhen you hit *Ctrl-C*, you send a SIGINT signal to each process in the current process group. A process group is set of processes that are all supposed to end together as a group instead of persisting independently. However, some programs, such as Emacs, intercept and repurpose SIGINT so that it does not end the process. In such cases, SIGINT should not end any processes of the group. Here is how you can delegate the decision to terminate to a child process:\n\n```js\nvar nodeCleanup = require('node-cleanup');\nvar fork = require('child_process').fork;\n\nvar child = fork('path-to-child-script.js');\nchild.on('exit', function (exitCode, signal) {\n    child = null; // enable the cleanup handler\n    if (signal === 'SIGINT')\n        process.kill(process.pid, 'SIGINT');\n});\n\nnodeCleanup(function (exitCode, signal) {\n    if (child !== null && signal === 'SIGINT')\n        return false; // don't exit yet\n    // release resources here before node exits\n});\n```\n\n## Reference\n\n### `nodeCleanup()`\n\n`nodeCleanup()` has the following available ([FlowType](https://flowtype.org/docs/getting-started.html#_)) signatures:\n\n```\nfunction nodeCleanup(cleanupHandler: Function): void\nfunction nodeCleanup(cleanupHandler: Function, stderrMessages: object): void\nfunction nodeCleanup(stderrMessages: object): void\nfunction nodeCleanup(): void\n```\n\nThe 1st form installs a cleanup handler. The 2nd form also assigns messages to write to `stderr` on SIGINT or an uncaught exception. The 3rd and 4th forms only assign messages to write to `stderr`, without installing a cleanup handler. The 4th form assigns default `stderr` messages.\n\n`cleanupHandler` is a cleanup handler callback and is described in its own section below. When no cleanup handlers are installed, termination events all result in the process terminating, including signal events.\n\n`stderrMessages` is an object mapping any of the keys `ctrl_C` and `uncaughtException` to message strings that output to `stderr`. Set a message to the empty string `''` inhibit a previously-assigned message.\n\n`nodeCleanup()` may be called multiple times to install multiple cleanup handlers or override previous messages. Each handler gets called on each signal or termination condition. The most recently assigned messages apply.\n\n### `nodeCleanup.uninstall()`\n\n`nodeCleanup.uninstall()` uninstalls all installed cleanup handlers and voids the `stderr` message assignments. It may be called multiple times without harm.\n\nThis function is primarily useful when a signal occurs and the cleanup handler performs cleanup but disables immediate process termination. In this case, when it is finally time to terminate the process, the cleanup handlers shouldn't run again, so the process uninstalls the handlers before terminating itself.\n\n### Cleanup Handlers\n\nEach cleanup handler has the following ([FlowType](https://flowtype.org/docs/getting-started.html#_)) signature:\n\n```\nfunction cleanupHandler(exitCode: number|null, signal: string|null): boolean?\n```\n\nIf the process is terminating for a reason other than a POSIX signal, `exitCode` is the exit code, and `signal` is null. Otherwise, if the process received a signal, `signal` is the signal's string name, and `exitCode` is null. These are the arguments passed to a [child process `exit` event](https://nodejs.org/api/child_process.html#child_process_event_exit) handler, mirrored here in `node-cleanup` for consistency.\n\nNode.js defines [these standard exit codes](https://nodejs.org/api/process.html#process_exit_codes), but it does not appear to use code values >128 for signals. According to the node.js docs, [these are the possible signals](http://man7.org/linux/man-pages/man7/signal.7.html), but the cleanup handlers only run on SIGINT (e.g. *Ctrl-C*), SIGHUP, SIGQUIT, or SIGTERM. (It is not possible to intercept SIGKILL.)\n\nThe return value of a cleanup handler is only significant for signals. If any cleanup handler returns a boolean `false`, the process does not exit. If they all return `true` (or for backwards compatibility, no return value), the process exits, reporting the signal to the parent process as the reason for the exit. The process always exits after calling the cleanup handlers for non-signals.\n\nWhen a cleanup handler returns `false` to prevent the process from exiting, the cleanup handler normally takes steps to ensure proper termination later. For example, the process may wait for asynchronous cleanup to complete, or it may wait for a child process to signal termination. Normally in these cases the process would use `nodeCleanup.uninstall()` to uninstall the cleanup handlers prior to the second termination to prevent them from running again.\n\nA cleanup handler should never call `process.exit()`. If a handler prevents a signal from terminating the process but later wishes to terminate the process for reason of this signal, the process should call `process.kill(process.pid, signal)`. In particular, the process should **not** call `process.exit(128 + signalNumber)`, because while this does communicate the exit code to the parent process, it does not communicate the exit signal by the means that the [node.js `child_process` expects](https://nodejs.org/api/child_process.html#child_process_event_exit).\n\n## Testing\n\nThis module includes an extensive test suite. You can run it from the module directory with either the [`tap`](http://www.node-tap.org/basics/) or [`subtap`](https://github.com/jtlapp/subtap) test runner, as follows:\n\n```\nnpm install -g tap\nnpm install\ntap tests/*.js\n```\n\nor\n\n```\nnpm install -g subtap\nnpm install\nsubtap\n```\n\n(As of this writing, the test suite has only been run on a Mac. Behavior may vary from OS to OS, so I'm looking for feedback from other operating systems.)\n\n## Incompatibilities with v1.0.x\n\n`node-cleanup` v2+ is not fully compatible with v1.x. You may need to change your usage to upgrade. These are the potential incompatibilities:\n\n- The cleanup handlers now also run on SIGHUP, SIGQUIT, and SIGTERM, which were not getting cleanup processing before.\n- `stderr` messages are handled quite differently. Previously, there were defaults that you had to override, and only your first message assignments applied. Now, the defaults **only** install with the parameterless call `nodeCleanup()`. Otherwise there are no messages unless you provide them. Moreover, the most recent message assignments are the ones that get used.\n\n## Acknowledgements\n\nThis module began by borrowing and modifying code from CanyonCasa's [answer to a stackoverflow question](http://stackoverflow.com/a/21947851/650894). I had found the code necessary for all my node projects. @Banjocat piped in with a [comment](http://stackoverflow.com/questions/14031763/doing-a-cleanup-action-just-before-node-js-exits/21947851#comment68567869_21947851) about how the solution didn't properly handle SIGINT. (See [this detailed explanation](https://www.cons.org/cracauer/sigint.html) of the SIGINT problem). I have completely rewritten the module to properly deal with SIGINT and other signals (I hope!). The rewrite also provides some additional flexibility that @zixia and I found ourselves needing for our respective projects.\n\n## License\n\n*This license applies to v2 and later. v1 derived from [this stackoverflow answer](http://stackoverflow.com/a/21947851/650894).*\n\nMIT License\n\nCopyright (c) 2016 Joseph T. Lapp\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":0,"column":7},"action":"insert","lines":["history"],"id":2}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":7},"end":{"row":0,"column":7},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1483254010000}